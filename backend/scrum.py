import threading
import time
import os
import datetime
import subprocess
from typing import Optional, Callable
from .memory import MemoryCore
from dotenv import load_dotenv

# Load Config
load_dotenv()
ENABLE_REAL_AGENTS = os.getenv("DCO_ENABLE_REAL_AGENTS", "false").lower() == "true" # Reads from DCO_ENABLE_REAL_AGENTS env var

class ScrumMaster:
    def __init__(self, subprocess_manager, memory_core: MemoryCore, broadcast_func: Optional[Callable[[dict], None]] = None):
        self.sm = subprocess_manager
        self.memory = memory_core
        self.broadcast_func = broadcast_func
        self.state = "IDLE"
        self.project_path = os.getcwd()
    
    def _set_state(self, new_state: str):
        """Updates state and broadcasts the change."""
        self.state = new_state
        print(f"[ScrumMaster] State changed to: {new_state}")
        if self.broadcast_func:
            self.broadcast_func({"type": "state_change", "state": new_state})

    def set_project_path(self, path: str):
        if os.path.exists(path):
            self.project_path = path
            self.memory.set_project_path(path)
            print(f"[ScrumMaster] Switched context to: {path}")

    def start_sprint(self, task_name: str):
        if self.state != "IDLE":
             print(f"[ScrumMaster] Busy. State: {self.state}")
             return

        # Run the workflow in a separate thread so we don't block the API
        workflow_thread = threading.Thread(target=self._run_sequential_workflow, args=(task_name,))
        workflow_thread.start()

    def _run_sequential_workflow(self, task_name: str):
        self._set_state("PLANNING")
        self.initialize_huddle(task_name)

        # --- PHASE 1: NAVIGATOR (Planning) ---
        print("[ScrumMaster] Starting Phase 1: Planning (Claude)")
        self._run_agent("claude", "NAVIGATOR", task_name)
        self.sm.wait_for_process("claude") # <--- WAIT FOR COMPLETION
        self._create_checkpoint("Plan Created")

        # --- PHASE 2: DRIVER (Building) ---
        self._set_state("BUILDING")
        print("[ScrumMaster] Starting Phase 2: Building (Codex)")
        self._run_agent("codex", "DRIVER", task_name)
        self.sm.wait_for_process("codex") # <--- WAIT FOR COMPLETION
        self._create_checkpoint("Build Implemented")

        # --- PHASE 3: REVIEW (Refining) ---
        self._set_state("REVIEWING")
        print("[ScrumMaster] Starting Phase 3: Reviewing (Claude)")
        self._run_agent("claude", "REVIEWER", task_name)
        self.sm.wait_for_process("claude") # <--- WAIT FOR COMPLETION
        self._create_checkpoint("Review Fixes")

        self._set_state("IDLE")
        print("[ScrumMaster] Sprint Completed.")

    def _create_checkpoint(self, message: str):
        """Creates a git commit to save progress."""
        try:
            # Check if inside a git repo
            if not os.path.exists(os.path.join(self.project_path, ".git")):
                return

            print(f"[ScrumMaster] Creating checkpoint: {message}")
            subprocess.run(["git", "add", "."], cwd=self.project_path, check=False, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            subprocess.run(["git", "commit", "-m", f"DCO Auto-Save: {message}"], cwd=self.project_path, check=False, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        except Exception as e:
            print(f"[ScrumMaster] Checkpoint failed: {e}")

    def initialize_huddle(self, task_name: str):
        path = os.path.join(self.project_path, ".brain/HUDDLE.md")
        os.makedirs(os.path.dirname(path), exist_ok=True)
        timestamp = datetime.datetime.now().strftime("%H:%M")
        content = f"# Sprint: {task_name}\n> Started: {timestamp}\n\n**System:** Workflow started.\n"
        with open(path, "w", encoding="utf-8") as f:
            f.write(content)

    def _run_agent(self, agent_name: str, role: str, task: str):
        """Constructs and runs the command."""
        huddle_path = ".brain/HUDDLE.md"
        context = self._get_context_prompt(task)
        
        # PROMPT CONSTRUCTION
        if role == "NAVIGATOR":
            prompt = (
                f"ROLE: NAVIGATOR. TASK: {task}\n{context}\n"
                f"ACTION: Read `.brain/SKILLS.md`. Write a detailed step-by-step implementation plan to `{huddle_path}`."
            )
            cmd = ["claude", "--print", prompt]
            
        elif role == "DRIVER":
            prompt = (
                f"ROLE: DRIVER. TASK: {task}\n{context}\n"
                f"ACTION: Read `{huddle_path}` to understand the plan. Implement the code files exactly as described."
            )
            cmd = ["codex", "-p", prompt]
            
        elif role == "REVIEWER":
            prompt = (
                f"ROLE: REVIEWER. TASK: {task}\n"
                f"ACTION: Read the code files generated by the Driver. Check for bugs or security issues. "
                f"If you find issues, append them to `{huddle_path}`."
            )
            cmd = ["claude", "--print", prompt]

        # EXECUTION
        if ENABLE_REAL_AGENTS:
            self.sm.start_subprocess(agent_name, cmd, cwd=self.project_path)
        else:
            # Simulated actions for testing
            mock_actions = {
                "NAVIGATOR": f"echo '[{agent_name}] Planning...'; sleep 3; echo '**Claude:** Plan created.' >> {huddle_path}",
                "DRIVER": f"echo '[{agent_name}] Reading Plan...'; sleep 3; echo '[{agent_name}] Writing main.py...'; sleep 2;",
                "REVIEWER": f"echo '[{agent_name}] Reviewing code...'; sleep 3; echo '**Claude:** Code looks good.' >> {huddle_path}"
            }
            mock_cmd = ["bash", "-c", mock_actions[role]]
            self.sm.start_subprocess(agent_name, mock_cmd, cwd=self.project_path)

    def _get_context_prompt(self, task):
        # (Simplified for brevity - reads systemPatterns.md)
        return f"Context for {task}"